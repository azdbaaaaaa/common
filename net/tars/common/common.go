// Package common comment
// This file was generated by tars2go 1.1
// Generated from common.tars
package common

import (
	"fmt"

	"github.com/TarsCloud/TarsGo/tars/protocol/codec"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = fmt.Errorf
var _ = codec.FromInt8

type AppIdEnum int32

const (
	AppIdEnum_LIGHT_HOUSE = 100
)

type AreaIdEnum int32

const (
	AreaIdEnum_ANDROID = 30
	AreaIdEnum_IOS     = 40
	AreaIdEnum_WEB     = 99
	AreaIdEnum_H5      = 98
)

type CheckLevelEnum int32

const (
	CheckLevelEnum_NORMAL              = 15
	CheckLevelEnum_NO_AUTO_RECOMMEND   = 10
	CheckLevelEnum_NO_MANUAL_RECOMMEND = 9
	CheckLevelEnum_NO_CHARGE           = 8
)

type MqSourceEnum int32

const (
	MqSourceEnum_TOPIC = 1
	MqSourceEnum_QUEUE = 2
)

type LanguageEnum int32

const (
	LanguageEnum_ZH = 0
	LanguageEnum_EN = 1
	LanguageEnum_ES = 2
	LanguageEnum_IN = 3
	LanguageEnum_TL = 4
	LanguageEnum_MS = 5
	LanguageEnum_KO = 6
)

type ContentSourceEnum int32

const (
	ContentSourceEnum_PDF_DRIVE = 1
	ContentSourceEnum_B_OK      = 2
	ContentSourceEnum_LIB_GEN   = 3
	ContentSourceEnum_CONTENT   = 4
)

type FileFormatEnum int32

const (
	FileFormatEnum_PDF  = 1
	FileFormatEnum_EPUB = 2
	FileFormatEnum_TXT  = 3
)

type LoginTypeEnum int32

const (
	LoginTypeEnum_GOOGLE    = 1
	LoginTypeEnum_FACEBOOK  = 2
	LoginTypeEnum_EMAIL     = 3
	LoginTypeEnum_GOOGLE_H5 = 4
)

type GenderEnum int32

const (
	GenderEnum_MALE    = 1
	GenderEnum_FEMALE  = 2
	GenderEnum_UNKNOWN = 0
)

//const as define in tars file
const (
	SUCCESS                int32 = 0
	ERROR_SERVER_FAIL      int32 = -100001
	ERROR_SERVER_PARAMETER int32 = -100002
	ERROR_SERVER_EXCEPTION int32 = -100003
	ERROR_SERVER_REJECT    int32 = -100004
	ERROR_SERVER_BUSY      int32 = -100005
	ERROR_CALL_TIMEOUT     int32 = -100006
	ERROR_CALL_EXCEPTION   int32 = -100007
	ERROR_CALL_BROKEN      int32 = -100008
	ERROR_BOOK             int32 = -101000
	ERROR_ID_SERVICE       int32 = -102000
	ERROR_SEARCH_SERVICE   int32 = -103000
	ERROR_OPERATION_CONFIG int32 = -104000
	ERROR_FEED_BACK        int32 = -105000
	ERROR_TAG              int32 = -106000
	ERROR_IMAGE            int32 = -107000
	ERROR_SYNC             int32 = -108000
	ERROR_BOOK_SEARCH      int32 = -109000
	ERROR_MQ               int32 = -110000
	ERROR_DEVICE_SERVICE   int32 = -120000
	ERROR_USER_SERVICE     int32 = -130000
	ERROR_FILE_CACHE       int32 = -140000
	ERROR_AUTHENTICATION   int32 = -150000
	ERROR_LOGIN            int32 = -160000
	BOOK_SERVICE           int32 = 200001
	MESSAGE_SERVICE        int32 = 200002
	USER_SERVICE           int32 = 200003
	AUTHENTICATION_SERVICE int32 = 200004
	SYNC_SERVICE           int32 = 200005
)

// InParam struct implement
type InParam struct {
	AppId    int32  `json:"appId"`
	AreaId   int32  `json:"areaId"`
	Version  int32  `json:"version"`
	UserId   int64  `json:"userId"`
	DeviceId string `json:"deviceId"`
	ClientIp string `json:"clientIp"`
	Channel  string `json:"channel"`
	Source   string `json:"source"`
	UserIp   string `json:"userIp"`
	Language string `json:"language"`
	Country  string `json:"country"`
	AuthorId int64  `json:"authorId"`
}

func (st *InParam) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *InParam) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.AppId, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.AreaId, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.Version, 2, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.UserId, 3, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.DeviceId, 4, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.ClientIp, 5, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Channel, 6, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Source, 7, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.UserIp, 8, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Language, 9, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Country, 10, false)
	if err != nil {
		return err
	}

	err = _is.Read_int64(&st.AuthorId, 11, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *InParam) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require InParam, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *InParam) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.AppId, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.AreaId, 1)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.Version, 2)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.UserId, 3)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.DeviceId, 4)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.ClientIp, 5)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Channel, 6)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Source, 7)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.UserIp, 8)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Language, 9)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Country, 10)
	if err != nil {
		return err
	}

	err = _os.Write_int64(st.AuthorId, 11)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *InParam) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// OutParam struct implement
type OutParam struct {
	Code    int32  `json:"code"`
	SubCode int32  `json:"subCode"`
	Message string `json:"message"`
}

func (st *OutParam) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *OutParam) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_int32(&st.Code, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_int32(&st.SubCode, 1, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.Message, 2, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *OutParam) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require OutParam, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *OutParam) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_int32(st.Code, 0)
	if err != nil {
		return err
	}

	err = _os.Write_int32(st.SubCode, 1)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.Message, 2)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *OutParam) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}

// ContentFilter struct implement
type ContentFilter struct {
	BlackCountries string `json:"blackCountries"`
	WhiteCountries string `json:"whiteCountries"`
}

func (st *ContentFilter) ResetDefault() {
}

//ReadFrom reads  from _is and put into struct.
func (st *ContentFilter) ReadFrom(_is *codec.Reader) error {
	var err error
	var length int32
	var have bool
	var ty byte
	st.ResetDefault()

	err = _is.Read_string(&st.BlackCountries, 0, false)
	if err != nil {
		return err
	}

	err = _is.Read_string(&st.WhiteCountries, 1, false)
	if err != nil {
		return err
	}

	_ = err
	_ = length
	_ = have
	_ = ty
	return nil
}

//ReadBlock reads struct from the given tag , require or optional.
func (st *ContentFilter) ReadBlock(_is *codec.Reader, tag byte, require bool) error {
	var err error
	var have bool
	st.ResetDefault()

	err, have = _is.SkipTo(codec.STRUCT_BEGIN, tag, require)
	if err != nil {
		return err
	}
	if !have {
		if require {
			return fmt.Errorf("require ContentFilter, but not exist. tag %d", tag)
		}
		return nil
	}

	err = st.ReadFrom(_is)
	if err != nil {
		return err
	}

	err = _is.SkipToStructEnd()
	if err != nil {
		return err
	}
	_ = have
	return nil
}

//WriteTo encode struct to buffer
func (st *ContentFilter) WriteTo(_os *codec.Buffer) error {
	var err error

	err = _os.Write_string(st.BlackCountries, 0)
	if err != nil {
		return err
	}

	err = _os.Write_string(st.WhiteCountries, 1)
	if err != nil {
		return err
	}

	_ = err

	return nil
}

//WriteBlock encode struct
func (st *ContentFilter) WriteBlock(_os *codec.Buffer, tag byte) error {
	var err error
	err = _os.WriteHead(codec.STRUCT_BEGIN, tag)
	if err != nil {
		return err
	}

	err = st.WriteTo(_os)
	if err != nil {
		return err
	}

	err = _os.WriteHead(codec.STRUCT_END, 0)
	if err != nil {
		return err
	}
	return nil
}
